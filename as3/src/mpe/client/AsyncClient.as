/*	AS3 Port of Daniel Shiffmans MostPixelsEver - client library	*/package mpe.client {		import flash.net.Socket;	import mpe.config.FileParser;		import flash.events.IOErrorEvent;	import flash.events.Event;	import flash.events.ErrorEvent;	import flash.events.SecurityErrorEvent;		public class AsyncClient{		public static var DEBUG:Boolean = false;		private var fp:FileParser;		public var running:Boolean = false;				public var hostName:String;		public var serverPort:int = 9003;				public var socket:Socket;		public function AsyncClient(_hostName:String = "localhost", _serverPort:int = 9003, loadFromIni:Boolean = false){						if(loadFromIni) { // assume _hostName is a path				loadIniFile(_hostName);				connect(hostName, serverPort);			}else{				connect(_hostName, _serverPort);			}					}		protected function loadIniFile(_fileString:String):void {			fp = new FileParser(_fileString);			if (!fp.fileExists())  return;			setServer(fp.getStringValue("server"));			setPort(fp.getIntValue("port"));			out("Settings: server = " + hostName + ":" + serverPort);						if (fp.getIntValue("debug") != 1) return; 			DEBUG = true;		}		protected function connect(_hostName:String, _serverPort:int):void {						setServer(_hostName);			setPort(_serverPort);						try{				socket = new Socket();//hostName, serverPort);				configureSocketListeners();				socket.connect(hostName, serverPort);			} catch (e:Error) {				trace("'" + e.name + "' : " + e.message);				throw new Error(e.name + " : " + e.message);			}		}		protected function setServer(_hostName:String):void {			if (_hostName != null)	hostName = _hostName;		}		protected function setPort(_serverPort:int):void {			if (_serverPort > -1) serverPort = _serverPort; 		}		public function getPort():int {			return serverPort;		}		public function broadcast(_msg:String):void {			send(_msg);		}		private function send(_msg:String):void {			if (DEBUG) out("Sending: " + _msg);			_msg = _msg + "\n";			try {				socket.writeUTFBytes(_msg); 				socket.flush();			}catch(e:Error) {				trace("ERROR: '" + e.name + "' : " + e.message);			}		}		protected function out(_str:String):void {			print(_str);		}		protected function print(_str:String):void {			trace("AsynchClient: " + _str);		}		protected function err(_str:String):void {			trace("ERROR: AsynchClient: " + _str);		}		//-----------------------------------------------------------------		// Added flash specific methods		//-----------------------------------------------------------------				private function configureSocketListeners():void {	        socket.addEventListener(Event.CLOSE, socketClosedEvent);	        socket.addEventListener(Event.CONNECT, socketConnectedEvent);	        socket.addEventListener(IOErrorEvent.IO_ERROR, socketError);	        socket.addEventListener(SecurityErrorEvent.SECURITY_ERROR, socketError);	        //socket.addEventListener(ProgressEvent.SOCKET_DATA, socketDataRecieved);	    }				// shouldn't recieve an event as its only for sending!		/*private function socketDataRecieved(e:ProgressEvent):void {	         out("socketDataRecieved : " + e + ":" + getTimer(), e.target.bytesAvailable + "bytes");			// [ProgressEvent type="socketData" bubbles=false cancelable=false eventPhase=2 bytesLoaded=29 bytesTotal=0]						//if(e.target.bytesAvailable > 0) read(e.target.readUTFBytes(e.target.bytesAvailable)); // readUTFBytes				    }*/				// Socket events.				private function socketClosedEvent(e:Event):void {	        out("socketClosedEvent: " + toString());	    }	    private function socketConnectedEvent(e:Event):void {	        out("socketConnectedEvent: " + toString());			running = true;	    }	    private function socketError(e:ErrorEvent):void {	        out("socketError: " + e.text);		}				public function toString():String {			return "{AsyncClient ip=" + hostName + ", port=" + serverPort + "}";		}	}}