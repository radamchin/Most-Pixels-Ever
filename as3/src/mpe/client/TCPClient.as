/*		TCPClient		AS3 Port of Daniel Shiffmans MostPixelsEver - client library	*/package mpe.client {	import flash.net.Socket;	import flash.utils.ByteArray;		import flash.errors.IOError;		import flash.events.IOErrorEvent;	import flash.events.Event;	import flash.events.ErrorEvent;	import flash.events.SecurityErrorEvent;	import flash.events.ProgressEvent;		import flash.utils.getTimer;	import flash.geom.Rectangle;		import flash.utils.Timer;	import flash.events.TimerEvent;	import flash.events.EventDispatcher;		import mpe.config.FileParser;		import com.bigbrowncupboard.ui.LogWindow;		public class TCPClient extends EventDispatcher {				public static var DEBUG:Boolean = false;				var fp:FileParser;				var running:Boolean= false;				 /** The id is used for communication with the server, to let it know which 	       *  client is speaking and how to order the screens. */		public var id:int = 0;				public var hostName:String;		public var serverPort:int = 9002;				public var socket:Socket;				//------------				public var numScreens:int; /** The total number of screens. */				protected var mWidth:int= -1; /** The master width. */		protected var mHeight:int= -1; /** The master height. */		protected var lWidth:int= 640; /** The local width. */		protected var lHeight:int= 480 /** The local height. */				var xOffset:int= 0;		var yOffset:int= 0;				var parent:MpeDataListener;		var frameEventMethod:Function = null;				var rendering:Boolean = false;		var autoMode:Boolean = false;				var serverFrameCount:int = -1;		var frameCount:int = 0;		var fps:Number = 0.0;		var lastMs:Number = 0;		/** True if all the other clients are connected. */		public var allConnected:Boolean = false;				protected var messageAvailable:Boolean;		protected var intsAvailable:Boolean;		protected var bytesAvailable:Boolean;		protected var dataMessage:Vector.<String>;				protected var ints:Vector.<int>;		protected var bytes:ByteArray;				// 3D variables		protected var enable3D:Boolean = false;		protected var fieldOfView:Number = 30.0;		protected var cameraZ:Number;				// adamh added		protected var _localBounds:Rectangle = new Rectangle();		protected var _masterBounds:Rectangle = new Rectangle();						protected var _auto_reconnect:Boolean = false;		protected var _connection_timer:Timer;		protected var _connection_check_interval:int = 1000 * 30; // how often to check for not being _connected and try to reconnect								public static const FRAME_EVENT:String = "frame_event";				protected var _instant_done:Boolean = false; // swicth to call the done method before the render frameEventCallback				private var frameEvent:Event = new Event(FRAME_EVENT); 		// store as single event to avoid memory usage. seems to work but not sure about bubbling or adding custom values to the event.				// custom functions to send print and error messages to.		private var _printMethod:Function;		private var _errorMethod:Function;								public function TCPClient(_iniFile:*, _p:MpeDataListener = null, _autoMode:Boolean = false) {			// useProcessing = true;			parent = _p;// p5parent = _p;			enable3D = false; // TODO this if needed in flash 3d p5parent.g is PGraphics3D;			autoMode = _autoMode;			cameraZ = 0; // (p5parent.height / 2.0F/ PApplet.tan(3.141593F* fieldOfView / 360.0F));			if(_iniFile is String) {								if(_iniFile.toLowerCase().indexOf(".xml") != -1) {					loadIniXML(new XML(loadIniFile(_iniFile)))				}else{					loadIniFile(_iniFile);				}							}else if(_iniFile is XML){				trace("ini is XML!");				loadIniXML(_iniFile as XML);			}else if(_iniFile is Object) {				loadIniObject(_iniFile);			}						connect(hostName, serverPort, id);					/*	if(parent != null) { 				if("frameEvent" in parent) { // TODO: might need to do this more robust with get class or something?					// may be not needed as if _p conforms to MpeDataListener it must have the frameEvent,					frameEventMethod = parent.frameEvent;				}else{					out("WARNING: You are missing the frameEvent() method.");				}			}*/						if(autoMode) {				//p5parent.registerDraw(this);				// TODO: need to make a movieclip and add it to the display list ?				// or a timer that is connected to fps equiv interval?			}		}				public function setFrameEventCallback(f:Function):void {			frameEventMethod = f;		}				//--------------------------------------------------------------		// Called automatically by PApplet.draw() when using auto mode.		//--------------------------------------------------------------				public function draw():void { // TODO: render event - needs to be on enter/exit framed?			if(running && rendering) {				//placeScreen();								//trace("mpe:TCPClient:draw:frameEventMethod = " + frameEventMethod);								if(_instant_done) done();								dispatchEvent(frameEvent); // for util things that listen to this.								if(frameEventMethod != null) {					//frameEventMethod(this); Function					frameEventMethod(); // .call(); // apply(null, this);										/*try{						// frameEventMethod.invoke(p5parent, new Object[] { this });						frameEventMethod(this);							}catch (e:Error) {						err("Could not invoke the \"frameEvent()\" method for some reason.");						trace("ERROR : '" + e.name + "' : " + e.message);						//frameEventMethod = null;					}*/				}								if(!_instant_done)  done();			}		}		//--------------------------------------------------------------		// Loads the settings from the Client INI file.		//--------------------------------------------------------------				private function loadIniObject(ini:Object):void {			// TODO: inititalise from an object eg, {server:"localhost", port:"1233" ..etc, }					}						private function loadIniXML(ini_xml:XML):void {						out("loadIniXML:" + ini_xml.toXMLString());						setServer(ini_xml.attribute("server"));			setPort(parseInt(ini_xml.attribute("port")));			setID(parseInt(ini_xml.attribute("id")));						numScreens = parseInt(ini_xml.attribute("totalScreens"));			numScreens = isNaN(numScreens) ? 1 : numScreens;						// TODO: these XML parses could be done in an XML version of the FileParser, to reuse code and report errors.						var tmp_coords:Array = ini_xml.attribute("localScreenSize").split(",");			var localDim:Vector.<int> = Vector.<int>([parseInt(tmp_coords[0]), parseInt(tmp_coords[1])]);			_setLocalDimensions(localDim[0], localDim[1]);						tmp_coords = ini_xml.attribute("localLocation").split(",");			var offsets:Vector.<int> = Vector.<int>([parseInt(tmp_coords[0]), parseInt(tmp_coords[1])]);			setOffsets(offsets[0], offsets[1]);						tmp_coords = ini_xml.attribute("masterDimensions").split(",");			var masterDims:Vector.<int> = Vector.<int>([parseInt(tmp_coords[0]), parseInt(tmp_coords[1])]);			setMasterDimensions(masterDims[0], masterDims[1]);						_auto_reconnect = (ini_xml.attribute("auto_reconnect") == "1");						_instant_done = (ini_xml.attribute("instant_done") == "1");						if(_auto_reconnect) {								if(ini_xml.attribute("connection_check_interval_secs").length > 0) {					_connection_check_interval = parseFloat(ini_xml.attribute("connection_check_interval_secs")) * 1000;					if(isNaN(_connection_check_interval) || _connection_check_interval > 1) {						_connection_check_interval = 15 * 1000; // default to 15 seconds if it					}				}								trace("mpe using auto_reconnect, checking every " + _connection_check_interval + " milliseconds.");								_connection_timer = new Timer(_connection_check_interval);				_connection_timer.addEventListener(TimerEvent.TIMER, testForConnection);				_connection_timer.start();			}						out("Settings: server=" + hostName + ":" + serverPort + ", id=" + id + 			", local dimensions=" + lWidth + "," + lHeight + 			", location=" + xOffset + "," + yOffset);						DEBUG = (ini_xml.attribute("debug") == "1");		}				private function loadIniFile(fileString:String):String {			fp = new FileParser(fileString);			if(!fp.fileExists()) return "";						if(fileString.toLowerCase().indexOf(".xml") != -1) return fp.contents; // it was an xml file refence so get outta here						setServer(fp.getStringValue("server"));			setPort(fp.getIntValue("port"));			setID(fp.getIntValue("id"));			var localDim:Vector.<int> = fp.getIntValues("localScreenSize");			_setLocalDimensions(localDim[0], localDim[1]);			var offsets:Vector.<int> = fp.getIntValues("localLocation");			setOffsets(offsets[0], offsets[1]);			var masterDims:Vector.<int> = fp.getIntValues("masterDimensions");			setMasterDimensions(masterDims[0], masterDims[1]);			out("Settings: server=" + hostName + ":" + serverPort + ", id=" + id + 			", local dimensions=" + lWidth + "," + lHeight + 			", location=" + xOffset + "," + yOffset);			if(fp.getIntValue("debug") != 1) {				return "";			}						return fp.contents;						//DEBUG = true;		}		private function connect(_hostName:String, _serverPort:int, _id:int):void {						socket = new Socket(); // start() method will call the connect() method of the socket.			configureSocketListeners();						setServer(_hostName);			setPort(_serverPort);			setID(_id);		}				protected function setServer(_hostName:String):void {			if(_hostName != null) hostName = _hostName;		}				public function getHostname():String { // adamh added.			return hostName;		}		protected function setPort(_serverPort:int):void {			if(_serverPort > -1) serverPort = _serverPort;		}		public function getPort():int {			return serverPort;		}		protected function setID(_id:int):void {			if(_id > -1) id = _id;		}		public function getID():int {			return id;		}		//--------------------------------------------------------------		// Sets the dimensions for the local display.		//--------------------------------------------------------------		protected function _setLocalDimensions(_lWidth:int, _lHeight:int):void {			if((_lWidth > -1) && (_lHeight > -1)) {				lWidth = _lWidth;				lHeight = _lHeight;				updateLocalBounds();			}		}		//--------------------------------------------------------------		// Sets the offsets for the local display.		//--------------------------------------------------------------		protected function setOffsets(_xOffset:int, _yOffset:int):void {			if((_xOffset > -1) && (_yOffset > -1)) {				xOffset = _xOffset;				yOffset = _yOffset;				updateLocalBounds();			}		}				//--------------------------------------------------------------		// Sets the dimensions for the local display.		// The offsets are used to determine what part of the Master Dimensions to render.		// For example, if you have two screens, each 100x100, and the master dimensions are 200x100		// then you would set		//  client 0: setLocalDimensions(0, 0, 100, 100);		//  client 1: setLocalDimensions(100, 0, 100, 100);		// for a 10 pixel overlap you would do:		//  client 0: setLocalDimensions(0, 0, 110, 100);		//  client 1: setLocalDimensions(90, 0, 110, 100);		//--------------------------------------------------------------		public function setLocalDimensions(_xOffset:int, _yOffset:int, _lWidth:int, _lHeight:int):void { 			// renamed from setLocalDimensions to avoid the overload error in as3			setOffsets(_xOffset, _yOffset);			_setLocalDimensions(_lWidth, _lHeight);		}		//--------------------------------------------------------------		// Sets the master dimensions for the Video Wall. 		// This is used to calculate what is rendered.		//--------------------------------------------------------------		public function setMasterDimensions(_mWidth:int, _mHeight:int):void {			if((_mWidth > -1) && (_mHeight > -1)) {				mWidth = _mWidth;				mHeight = _mHeight;				updateMasterBounds();			}		}		//--------------------------------------------------------------				private function testForConnection(e:TimerEvent):void {							if(!connected){				start();			}					}				protected function updateLocalBounds():void {			_localBounds.x = xOffset;			_localBounds.y = yOffset;			_localBounds.width = lWidth;			_localBounds.height = lHeight;		}				protected function updateMasterBounds():void {			_masterBounds.width = mWidth;			_masterBounds.height = mHeight;		}				//--------------------------------------------------------------				public function getLWidth():int {			return lWidth;		}				public function getLHeight():int {			return lHeight;		}				public function getXoffset():int {			return xOffset;		}				public function getYoffset():int {			return yOffset;		}				public function getMWidth():int {			return mWidth;		}				public function getMHeight():int {			return mHeight;		}				public function getLocalBounds():Rectangle {			return _localBounds;		}				public function getMasterBounds():Rectangle {			return _masterBounds;		}					public function getFrameCount():int {			return frameCount;		}				public function setFrameCount(v:int):void { // backdoor so i can reset it to get system running again after a break			frameCount = v;		}				public function getFPS():Number {			return fps;		}				public function isRendering():Boolean {			return rendering;		}		public function getServerFrameCount():int {			return serverFrameCount;		}				//--------------------------------------------------------------		// Sets the field of view of the camera when rendering in 3D.		// Note that this has no effect when rendering in 2D.		//--------------------------------------------------------------		public function setFieldOfView(val:Number):void {			fieldOfView = val;		/*	TODO: equate to flash 3d equiv code.			if(p5parent != null) {				cameraZ = (p5parent.height / 2.0F/ PApplet.tan(3.141593F* fieldOfView / 360.0F));				if(!p5parent.g is PGraphics3D) {					out("MPE Warning: Rendering in 2D! fieldOfView has no effect!");				}else{					out("MPE Warning: Not using Processing! fieldOfView has no effect!");				}			}*/		}		public function getFieldOfView():Number {			return fieldOfView;		}				//--------------------------------------------------------------		// Places the viewing area for this screen. This must be called at the 		// beginning of the render loop.  If you are using Processing, you would 		// typically place it at the beginning of your draw() function.		//--------------------------------------------------------------		public function placeScreen():void {			if(enable3D){				placeScreen3D();			}else{				placeScreen2D();			}		}		//--------------------------------------------------------------		// If you want to enable or disable 3D manually in automode		//--------------------------------------------------------------		public function setEnable3D(b:Boolean):void { // renamed from enable3D()			enable3D = b;		}			//--------------------------------------------------------------		// Places the viewing area for this screen when rendering in 2D.		//--------------------------------------------------------------		public function placeScreen2D():void {			// p5parent.translate(xOffset * -1, yOffset * -1);			// TODO: perhaps this is how drawing is being acheived ? offseting the canvas of the p5 renderer! 			// Will need flash to just read the offset values instead and do this all a bit more manual.		}			//--------------------------------------------------------------		// Places the viewing area for this screen when rendering in 3D.		//--------------------------------------------------------------		public function placeScreen3D():void {		/*	TODO: Flash 3d equiv.		p5parent.camera(mWidth / 2.0F, mHeight / 2.0F, cameraZ, 			mWidth / 2.0F, mHeight / 2.0F, 0.0F, 0.0F, 1.0F, 0.0F);								    // The frustum defines the 3D clipping plane for each Client window!			var mod:Number= 0.1F;			var left:Number= (xOffset - mWidth / 2) * mod;			var right:Number= (xOffset + lWidth - mWidth / 2) * mod;			var top:Number= (yOffset - mHeight / 2) * mod;			var bottom:Number= (yOffset + lHeight - mHeight / 2) * mod;			var near:Number= cameraZ * mod;			var far:Number= 10000.0F;			p5parent.frustum(left, right, top, bottom, near, far);			*/		}			//--------------------------------------------------------------		// Restores the viewing area for this screen when rendering in 3D.		//--------------------------------------------------------------		public function restoreCamera():void {		/*	p5parent.camera(p5parent.width / 2.0F, p5parent.height / 2.0F, cameraZ, 				p5parent.width / 2.0F, p5parent.height / 2.0F, 0.0F, 				0.0F, 1.0F, 0.0F);			var mod:Number= 0.1F;			p5parent.frustum(-(p5parent.width / 2) * mod, p5parent.width / 2* mod, 				-(p5parent.height / 2) * mod, p5parent.height / 2* mod, 				cameraZ * mod, 10000.0F);*/		}		//--------------------------------------------------------------		// Checks whether the given point is on screen.		//--------------------------------------------------------------		public function isOnScreen(x:Number, y:Number):Boolean {			return (x > xOffset) && 				(x < xOffset + lWidth) && 				(y > yOffset) && 				(y < yOffset + lHeight);		}				//--------------------------------------------------------------		// Checks whether the given rectangle is on screen.		//--------------------------------------------------------------		public function isRectOnScreen(x:Number, y:Number, w:Number, h:Number):Boolean { 			// renamed from isOnScreen to avoid as3 no method overloads			return (isOnScreen(x, y)) || 				(isOnScreen(x + w, y)) || 				(isOnScreen(x + w, y + h)) || 				(isOnScreen(x, y + h));		}				//--------------------------------------------------------------		private function out(_str:String):void {			print(_str);		}				public function setPrintMethod(m:Function):void {			_printMethod = m;		}				public function setErrorMethod(m:Function):void {			_errorMethod = m;		}				private function print(_str:String):void {			if(_printMethod != null) {				_printMethod("mpe:TCPClient:" + _str);			}else{				trace("mpe:TCPClient:" + _str);			}		}		private function err(_str:String):void {			if(_errorMethod != null) {				_errorMethod("mpe:TCPClient:" + _str);			}else{				trace("ERROR:mpe:TCPClient:" + _str);			}		}		//--------------------------------------------------------------			public function start():void { // this is from Thread maybe?			try{				out("About to connect");				socket.connect(hostName, serverPort);							} catch (e:Error) {				err("'" + e.name + "' : " + e.message);				throw new Error(e.name + " : " + e.message);			}		}		/*public function run():void { // Thread event ?? needs to be on socket event?			if(DEBUG) out("Running!");		 	send("S" + id); // so is this constantly being sent? No its a join message from looking at Server source code.			try{				while (running){					var msg:String = brin.readLine();					if(msg == null) {						break;					}					read(msg);					try{						Thread.sleep(5L);					} catch (e:InterruptedException) {						e.printStackTrace();					}				}				is.close();			} catch (e:IOException) {				e.printStackTrace();			}		}*/		private function read():void {						var _serverInput:String = socket.readUTFBytes(socket.bytesAvailable);						if(DEBUG) out("Receiving: '" + _serverInput + "', " + _serverInput.length);						var c:String = _serverInput.charAt(0); // frame message id char.						if((c == 'G') || (c == 'B') || (c == 'I')) {				if(!allConnected) {					if(DEBUG) out("all connected!");					allConnected = true;				}								// TODO: here is where we could save some memory allocation by reusing objects better								// split into frame message and data message				var info:Array = _serverInput.split(":");				var frameMessage:Array = info[0].split(",");				serverFrameCount = parseInt(frameMessage[1]);				var il:int = info.length								if(il > 1){ // There is a message here with the frame event					var dataInfo:Vector.<String> = new Vector.<String>(il - 1);					for (var k:int= 1; k < il; ++k) {						dataInfo[(k - 1)] = info[k];						//if(DEBUG) out("\tunpack msg[" + k + "] = " + info[k]);					}					dataMessage = null;					dataMessage = dataInfo;					messageAvailable = true;				}else{					messageAvailable = false;				}								// assume no arrays are available				intsAvailable = false;				bytesAvailable = false;								   /*if (c == 'B') {		                int len;		                try {		                    len = dis.readInt();		                    bytes = new byte[len];		                    if (DEBUG) out("Receiving bytes: " + len);		                    dis.read(bytes,0,len);		                    bytesAvailable = true;		                    waitToSend = false;		                } catch (IOException e) {		                    e.printStackTrace();		                }		            } else if (c == 'I') {		                int len;		                try {		                    len = dis.readInt();		                    if (DEBUG) out("Receiving ints: " + len);		                    ints = new int[len];		                    for (int i = 0; i < ints.length; i++) {		                        ints[i] = dis.readInt();		                    }		                    intsAvailable = true;		                    waitToSend = false;		                } catch (IOException e) {		                    e.printStackTrace();		                }		            }*/						if(serverFrameCount == frameCount){					rendering = true;					frameCount += 1;										// calculate new framerate					//var ms:Number= (getTimer() - lastMs);					fps = (1000.0/(getTimer() - lastMs));					lastMs = getTimer();					if(autoMode) return;									//parent.frameEvent(this);					draw(); // added adamh, should the frameEvent be calling this manually?									}else{					if(!DEBUG) return; 					print("Extra message, frameCount: " + frameCount + " received from server: " + serverFrameCount);				}							}					}				/*public void broadcastByteArray(byte[] data, int len) {	        // We won't send an int array more than	        // once during any given "frame"	        if (!waitToSend) {	            waitToSend = true;	            broadcastingData = true;	            String msg = "B";	            send(msg);	            if (DEBUG) System.out.println("Sending: " + data.length + " bytes.");	            try {	                dos.writeInt(len);	                dos.write(data, 0, len);	                dos.flush();	            } catch (IOException e) {	                e.printStackTrace();	            }	            broadcastingData = false;	            // If we finished while this was happening, we didn't say we were done	            // So we need to now	            if (sayDoneAgain) {	                done();	                sayDoneAgain = false;	            }	        } else {	            if (DEBUG) System.out.println("Gotta wait dude, haven't received the ints back yet.");	        }	    }*/	    /**	     * broadcasts an array of ints to all screens	     * Large arrays can cause performance problems	     * @param data the array to broadcast	     */      	    /*public synchronized void broadcastIntArray(int[] data) {	        // We won't send an int array more than	        // once during any given "frame"	        if (!waitToSend) {	            waitToSend = true;	            broadcastingData = true;	            String msg = "I";	            send(msg);	            if (DEBUG) System.out.println("Sending: " + data.length + " bytes.");	            try {	                dos.writeInt(data.length);	                for (int i = 0; i < data.length; i++) {	                    dos.writeInt(data[i]);	                }	                dos.flush();	            } catch (IOException e) {	                e.printStackTrace();	            }	            broadcastingData = false;	            // If we finished while this was happening, we didn't say we were done	            // So we need to now	            if (sayDoneAgain) {	                done();  // HACK TO SAY WE'RE DONE AGAIN!!!	                sayDoneAgain = false;	            }	        } else {	            if (DEBUG) System.out.println("Gotta wait dude, haven't received the ints back yet.");	        }	    }*/			//--------------------------------------------------------------		// Send a message to the server.		//--------------------------------------------------------------				private function send(_msg:String, now:Boolean = true):void {						if(DEBUG) out("Sending: '" + _msg + "'" + ", " + _msg.length);						try {				socket.writeUTFBytes(_msg + "\n"); // add the return as it defines a message				if(now) socket.flush();			}catch(e:Error) {				err("mpe:send[" + _msg + "] '" + e.name + "' : " + e.message);			}		}				public function finalize():void {						/*				flush the socket, useful when sending multiples using a now=false arg on send			*/						try {				socket.flush();			}catch(e:IOError) {				err("mpe:finalize: '" + e.name + "' : " + e.message);			}			}				/**	     * broadcasts a byte array to all screens	     * Large arrays could cause performance issues	     * depending on network speed	     * @param data the array to broadcast	     */	    /*public void broadcastByteArray(byte[] data) {	        broadcastByteArray(data,data.length);	    }*/	 		//--------------------------------------------------------------		// Format a broadcast message and send it.		// Do not use a colon ':' in your message!!!		//--------------------------------------------------------------				public function broadcast(_msg:String, now:Boolean = true):void {			send("T" + _msg, now);		}		public function getMessageAvailable():Boolean { // renamed from messageAvailable()			return messageAvailable;		}		public function getDataMessage():Vector.<String> {			return dataMessage;		}		public function getIntsAvailable():Boolean { //renamed from intsAvailable()			return intsAvailable;		}		public function getInts():Vector.<int> {			return ints;		}		public function getBytesAvailable():Boolean { // renamed from bytesAvailable()			return bytesAvailable;		}		public function getBytes():ByteArray{			return bytes;		}				//--------------------------------------------------------------		// Sends a "Done" command to the server. This must be called at 		// the end of the draw loop.		//--------------------------------------------------------------				public function done():void {			rendering = false;			send("D," + id + "," + frameCount);		}				//--------------------------------------------------------------		// Stops the client thread.  You don't really need to do this ever.		//--------------------------------------------------------------		public function quit():void {			out("Quitting.");			running = false;			// interrupt(); // thread method			socket.close();		}				//-----------------------------------------------------------------		// Added flash specific methods		//-----------------------------------------------------------------				private function configureSocketListeners():void {	        socket.addEventListener(Event.CLOSE, socketClosedEvent);	        socket.addEventListener(Event.CONNECT, socketConnectedEvent);	        socket.addEventListener(IOErrorEvent.IO_ERROR, socketError);	        socket.addEventListener(SecurityErrorEvent.SECURITY_ERROR, socketError);	        socket.addEventListener(ProgressEvent.SOCKET_DATA, socketDataRecieved);	    }				private function socketDataRecieved(e:ProgressEvent):void {	        // out("socketDataRecieved : " + e + ":" + getTimer() + ", " + e.target.bytesAvailable + "bytes");			// [ProgressEvent type="socketData" bubbles=false cancelable=false eventPhase=2 bytesLoaded=29 bytesTotal=0]						//if(e.target.bytesAvailable > 0) read(e.target.readUTFBytes(e.target.bytesAvailable));			if(socket.bytesAvailable > 0) read();						/*while(event.target.bytesAvailable > 0) {					buf_str = event.target.readUTFBytes(1);					//trace(buf_str);											if(buf_str == "\t") { // we have hit the message end token						parseStringMessage();					}else{						message_str += buf_str;					}			}*/				    }			public function get connected():Boolean {			return socket.connected; // or running		}				// Socket events.				private function socketClosedEvent(e:Event):void {	        err("mpe.socketClosedEvent: connected=" + connected +" : " + toString());			running = false;	    }	    private function socketConnectedEvent(e:Event):void {	        out("socketConnectedEvent: " + toString());			send("S" + id); // let the server know that this client is ready to start			running = true;	    }	    private function socketError(e:ErrorEvent):void {	        err("mpe:socketError: " + e.text);		}				public override function toString():String {			return "{mpe id=" + getID() + " / " + (numScreens-1) + ", local=" + _localBounds + ", master=" + _masterBounds + ", rendering=" + rendering + ", fps=" + fps + ", frameCount=" + frameCount + ", ip=" + hostName + ":" + serverPort + ", instant_done=" + _instant_done + " }";		}			}}