/*	AS3 Port of Daniel Shiffmans MostPixelsEver - client library		BallsTest 	Replicates mpeTest.pde with Ball drawing etc.	Also sends keydown string over Asynch client			Will be used multiple times, so needs build id to work	*/package mpe.examples {		import mpe.client.TCPClient;	import mpe.client.MpeDataListener;		import mpe.client.AsyncClient;		import mpe.ui.MPEStatusWidget;		import flash.display.MovieClip;	import flash.utils.getTimer;	import flash.events.Event;		import flash.display.DisplayObjectContainer;	import flash.text.TextFormat;	import flash.text.Font;	import flash.text.TextFieldAutoSize;		import flash.geom.Rectangle;	import flash.display.Sprite;	import flash.display.StageScaleMode;	import flash.display.StageAlign;		import flash.display.Screen;	import flash.desktop.NativeApplication;		import com.gskinner.utils.Rndm; // Used for ability to seed random	import flash.events.MouseEvent;		import flash.text.TextField;			import flash.events.KeyboardEvent;			public class BallsTest extends MovieClip {// implements MpeDataListener{				private var mpe:TCPClient;		public static const build_id:int = CONFIG::BUILD_ID;				private var asyncer:AsyncClient;				private var _overlay:Sprite;				private var balls:Vector.<Ball>;		private var canvas:Sprite;				private var keyfield:TextField				public function BallsTest(){			trace("BallsTest:" + build_id , "CONFIG::BUILD_ID=" + CONFIG::BUILD_ID);			addEventListener(Event.ADDED_TO_STAGE, added);			Rndm.seed = 1956;		}		private function added(e:Event):void {						removeEventListener(Event.ADDED_TO_STAGE, added);				init();		}				public function init():void {						stage.scaleMode = StageScaleMode.NO_SCALE;			stage.align = StageAlign.TOP_LEFT;							mpe = new TCPClient("app:/data/mpe" + build_id + ".xml");			mpe.setFrameEventCallback(mpeFrameCallback);						// using Air code, auto resize and position the window to whats in the mpe			var screenBounds:Rectangle = Screen.mainScreen.visibleBounds;// Main screens rect.			var mpeBounds:Rectangle = new Rectangle(mpe.getXoffset(), mpe.getYoffset(), mpe.getLWidth(), mpe.getLHeight());						stage.nativeWindow.x = screenBounds.left + mpeBounds.left + (mpeBounds.left != 0 ? 1 : 0);			stage.nativeWindow.y = screenBounds.top + mpeBounds.top + (mpeBounds.top != 0 ? 1 : 0);			stage.nativeWindow.width = mpeBounds.width;			stage.nativeWindow.height = mpeBounds.height;						NativeApplication.nativeApplication.autoExit = true; // quit when all windows are closed						var mpeMasterBounds:Rectangle = new Rectangle(0, 0, mpe.getMWidth(), mpe.getMHeight());						_overlay = addChild(new Sprite()) as Sprite;			//createText(_overlay, mpe.id + " : local=" + mpeBounds + "\nmaster= " + mpeMasterBounds, 70, 0, 12);			// DisplayObjectUtils.drawText(target:DisplayObjectContainer, val:String, x:Number, y:Number, size:int = 15					keyfield = createText(_overlay, "KeysRecieved:", 5, 120, 12, true, true);			keyfield.width = 220;						if(build_id == 0) {				asyncer = new AsyncClient(mpe.getHostname(), 9002); // or this could be a ini thing too ? send in from ini, esp the port.				stage.addEventListener(KeyboardEvent.KEY_DOWN, keyDown);			}						// add a "randomly" placed ball			balls = new Vector.<Ball>();			var b:Ball = new Ball(mpe, Rndm.float(mpe.getMWidth()), Rndm.float(mpe.getMHeight()) );			balls.push(b);			//b.draw(graphics);						mpe.start();						addChild(new MPEStatusWidget(mpe,asyncer, 5, 5));			canvas = addChild(new Sprite()) as Sprite;							stage.addEventListener(MouseEvent.CLICK, clickEvent);		}						public function mpeFrameCallback():void {			// callback method from client?			// change the screen rerender.			//trace("BallsTest: " + build_id + ":frameEvent:" + mpe + " balls=" + balls.length + " : " + getTimer());			canvas.graphics.clear();						var b:Ball;			for (var i:int = 0; i < balls.length; i++) { 				b = balls[i];				b.calc();				if(mpe.isRectOnScreen(b.x - b.r, b.y - b.r, b.r * 2, b.r * 2)) {	               b.draw(canvas.graphics);	           	}			}						if (mpe.getMessageAvailable()) {				// custom message to spawn a new ball. to be done on a click				var msg:Vector.<String> = mpe.getDataMessage();				trace("MessageAvailable= length:" + msg.length + ", msg=" + msg);				if(msg.length){					var args:Array = msg[0].split(",");					var id:String =  args[0];					if(id == Ball.MAKE_BALL) {						balls.push(new Ball(mpe, parseFloat(args[1]), parseFloat(args[2])));					}else if(id == "KEY") {						var keystr:String = args[1];						keystr = keystr.substr(0,-1);// remove the last char as it will be a return						keyfield.appendText(keystr);					}				}			}					}				private function clickEvent(e:MouseEvent):void {			var x:Number = e.stageX + mpe.getXoffset();			var y:Number = e.stageY + mpe.getYoffset();			mpe.broadcast(Ball.MAKE_BALL + "," + x + "," + y);		}				private function keyDown(e:KeyboardEvent):void {			trace("keyDown:" + e.charCode +", " + e.keyCode + ", '" + String.fromCharCode(e.charCode) + "'");			asyncer.broadcast("KEY," + String.fromCharCode(e.charCode));			// could just use the mpe to broadcast this as async is more for client that does not need to be connected. need to test though.		}				private function createText(target:DisplayObjectContainer = null, val:String = "", x:Number = 0, y:Number = 0, size:int = 15, auto_add_child:Boolean = true, wordwrap:Boolean = false, showbg:Boolean = true, targetFont:String = "Arial", auto_size:Boolean = true, color:uint = 0x000000):TextField {			var tf:TextField = new TextField();			tf.selectable = false;			tf.background = showbg;			tf.backgroundColor = 0xFFFFFF;			tf.wordWrap = wordwrap;					tf.text = val;					var newFormat:TextFormat = new TextFormat(); 			newFormat.size = size;			newFormat.color = color; 					// only embed fonts if i can find them			var fonts:Array = Font.enumerateFonts(false); // false -> embedded only.  could be slow if constantly being updated yeah?					for each(var font:Font in fonts) {				if(font.fontName == targetFont) {					tf.embedFonts = true;					newFormat.font = font.fontName;					break;					}			}					if(auto_size) tf.autoSize = TextFieldAutoSize.LEFT;			tf.x = x;			tf.y = y;			if(!tf.embedFonts) newFormat.font = targetFont;           			tf.setTextFormat(newFormat); // this one works when text is modified			tf.defaultTextFormat = newFormat; // this one works on the initial text.			if(auto_add_child && target != null) target.addChild(tf);			return tf;		}							}	}