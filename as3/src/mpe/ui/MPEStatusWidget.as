/*	MPEStatusWidget	UI widget, show|control the connection status to an MPE server and other stats			*/package mpe.ui {		import flash.geom.Rectangle;	import flash.geom.Point;		import flash.events.Event;	import flash.display.MovieClip;	import flash.display.Shape;		import flash.display.Bitmap;	import flash.display.BitmapData;		import com.bit101.components.Style;	import com.bit101.components.Label;	import com.bit101.components.InputText;		import mpe.client.TCPClient;	import mpe.client.AsyncClient;		import com.bigbrowncupboard.ui.SocketServerConnector;	import com.bigbrowncupboard.ui.StatusDot;		public class MPEStatusWidget extends MovieClip {				public var connector:SocketServerConnector;		public var async_connector:SocketServerConnector;				private var all_connected_status:StatusDot;		private var frame_status:StatusDot;				private var frame_count_ti:InputText;		private var server_frame_count_ti:Label;		private var frame_rate_label:Label;		private var avg_frame_rate_label:Label;				private var mpe_config_label:Label;				private var mpe:TCPClient;		private var async:AsyncClient;				private var update_count:uint = 0;		private var avg_fps:Number = 0;				private var avg_fps_table:Vector.<Number> =  new Vector.<Number>();		private const AVG_FPS_TABLE_LIMIT:int = 128;				protected var graph:Bitmap;		protected var graph_cliprect:Rectangle;				private var AVG_COL:uint = 0xFF00FF;		private var FPS_COL:uint = 0xFFFF00;				private var _inited:Boolean = false;				public function MPEStatusWidget(mpe:TCPClient, async:AsyncClient = null, x:Number = 0, y:Number = 0) {			this.mpe = mpe;			this.async = async;			this.x = x;			this.y = y;			addEventListener(Event.ADDED_TO_STAGE, added);			addEventListener(Event.REMOVED_FROM_STAGE, removed);			if(!_inited) init();		}				private function added(e:Event):void {			addEventListener(Event.ENTER_FRAME, update);			mpe.addEventListener(TCPClient.FRAME_EVENT, mpeFrameEvent);		}				private function removed(e:Event):void {			removeEventListener(Event.ENTER_FRAME, update);			mpe.removeEventListener(TCPClient.FRAME_EVENT, mpeFrameEvent);		}				private function init():void {			trace("MPEStatusWidget.init");						_inited = true;						var bg:Shape = new Shape();			addChild(bg);			bg.graphics.lineStyle(1, 0xFD0000, 0.0);			bg.graphics.beginFill(0xDEDEDE, .66);			bg.graphics.drawRect(0,0,254,75);			bg.graphics.endFill();						graph = new Bitmap(new BitmapData(157, async ? 29 : 49, false, 0x222222));			graph.x = 95;			graph.y = async ? 45 : 25;			addChild(graph);						graph_cliprect = new Rectangle(graph.width-1, 0, 1, graph.height);						Style.LABEL_TEXT = 0x000000;			var title_lab:Label = new Label(this, 0, 5, "MPE:");						connector = addChild(new SocketServerConnector(null, 30, 7)) as SocketServerConnector;						var frameLabelsOrigin:Point = new Point(30, 57); // lower if we are not master (i.e, not asynch) async ? 57 : 56						if(async != null) {				async_connector = addChild(new SocketServerConnector(null, 30, 26)) as SocketServerConnector;				var async_lab:Label = new Label(this, 0, 24, "async:");			}						all_connected_status = addChild(new StatusDot(StatusDot.BOX, 4, StatusDot.RED, 3, 3)) as StatusDot;			frame_status = addChild(new StatusDot(StatusDot.BOX, 4, StatusDot.CYAN, 13, 3)) as StatusDot;								var fc_lab:Label = new Label(this, 0, frameLabelsOrigin.y-14, "frame:");						frame_count_ti = new InputText(this, frameLabelsOrigin.x, frameLabelsOrigin.y-13, "0", frameCountChange);			frame_count_ti.setSize(62, 14);			frame_count_ti.textField.restrict = "1234567890";			frame_count_ti.textField.maxChars = 10;			 			server_frame_count_ti = new Label(this, frameLabelsOrigin.x+2, frameLabelsOrigin.y, "0"); // x +  + 36			server_frame_count_ti.setSize(62, 14);						Style.LABEL_TEXT = FPS_COL;			frame_rate_label = new Label(this, graph.x, frameLabelsOrigin.y, "0 fps");			Style.LABEL_TEXT = AVG_COL;			avg_frame_rate_label = new Label(this, graph.x+graph.width-46, frameLabelsOrigin.y, "0 av");						Style.LABEL_TEXT = 0xFFFFFF;			var config_str:String = " id=" + mpe.id + " / " + mpe.numScreens + "   pos=" + mpe.getXoffset() + "," +mpe.getYoffset() + "   dims=" + mpe.getLWidth() + "," + mpe.getLHeight() + "   master=" + mpe.getMWidth() + "," + mpe.getMHeight();						mpe_config_label = new Label(this, 0, frameLabelsOrigin.y+18, config_str);			mpe_config_label.textField.background = true;			mpe_config_label.textField.backgroundColor = 0x000000;						initConnectors();					}				public function initConnectors():void {			connector.attach(mpe.socket, mpe.hostName, String(mpe.serverPort));			if(!mpe.socket.connected) connector.socketConnecting(); // auto call until can work out how to make socket do this. 			if(async != null) {				async_connector.attach(async.socket, async.hostName, String(async.serverPort));				if(!async.socket.connected) async_connector.socketConnecting(); // auto call until can work out how to make socket do this.			}					}				public function update(e:Event = null):void {						// Show all clients connected status			if(mpe.allConnected) {				if(all_connected_status.value == StatusDot.RED) all_connected_status.update(StatusDot.GREEN);			}else{				if(all_connected_status.value != StatusDot.RED) all_connected_status.update(StatusDot.RED);			}						if(mpe.connected){								update_count++;								var selected:Boolean = (stage.focus == frame_count_ti); // frame_count_ti.focusManager.getFocus() == frame_count_ti;				if(!selected) frame_count_ti.text = String(mpe.getFrameCount());								server_frame_count_ti.text = String(mpe.getServerFrameCount());								avg_fps_table.push(mpe.getFPS());								var avg_ln:int = avg_fps_table.length;								if(avg_ln > AVG_FPS_TABLE_LIMIT) {					avg_fps_table.shift(); // remove one from the front					avg_ln = AVG_FPS_TABLE_LIMIT;				}								avg_fps = 0;				var c:int = avg_ln;				while(c--) avg_fps += avg_fps_table[c];								avg_fps /= avg_ln;								frame_rate_label.text = mpe.getFPS().toFixed(2) + " fps";				avg_frame_rate_label.text = avg_fps.toFixed(2) + " av";								drawFPSGraph();			}					}				private function drawFPSGraph():void {			var fps:Number = Math.min(graph.height, (mpe.getFPS() / stage.frameRate) * graph.height);			var avg:Number = Math.min(graph.height, (avg_fps / stage.frameRate) * graph.height);			graph.bitmapData.scroll(-1, 0);			graph.bitmapData.fillRect(graph_cliprect, 0x222222);			graph.bitmapData.setPixel(graph.width - 1, graph.height - avg, AVG_COL);			graph.bitmapData.setPixel(graph.width - 1, graph.height - fps, FPS_COL);		}				private function frameCountChange(e:Event):void {			trace("frameCountChange -> " + parseInt(frame_count_ti.text));			mpe.setFrameCount(parseInt(frame_count_ti.text));		}				public function mpeFrameEvent(e:Event):void {			// toggle the status widget to show we are pulsing frame events.			if(mpe.getFrameCount() % 3 == 0) { // every 3 frames flash it.				frame_status.visible = !frame_status.visible;			}		}			}	}